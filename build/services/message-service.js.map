{"version":3,"sources":["services/message-service.ts"],"names":[],"mappings":"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","file":"message-service.js","sourcesContent":["/*\n Copyright 2016-2017 Resin.io\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\nimport * as Promise from 'bluebird';\nimport * as bodyParser from 'body-parser';\nimport * as express from 'express';\nimport { Worker } from '../framework/worker';\nimport { WorkerClient } from '../framework/worker-client';\nimport {\n    Logger,\n    LogLevel,\n} from '../utils/logger';\nimport {\n    HandleContext, HandleIds,\n    MessengerEmitResponse,\n    MessengerEvent,\n    MessengerWorkerEvent, Metadata,\n    ReceiptContext, TransmitContext,\n} from '../utils/message-types';\nimport {\n    ServiceAPIHandle,\n    ServiceEmitContext,\n    ServiceEmitRequest,\n    ServiceEmitter,\n    ServiceListener,\n    ServiceRegistration,\n} from './service-types';\n\nexport abstract class MessageService extends WorkerClient<string|null> implements ServiceListener, ServiceEmitter {\n    /**\n     * Make a handle context, using a receipt context and some extra information\n     * @param event - Event to be converted\n     * @param to - Destination for the handle context\n     * @param toIds - Pre-populate the toIds, if desired\n     * @returns {HandleContext} - newly created context for handling a message\n     */\n    public static initHandleContext(event: ReceiptContext, to: string, toIds: HandleIds = {}): HandleContext {\n        return {\n            // Details from the ReceiptContext\n            action: event.action,\n            first: event.first,\n            genesis: event.genesis,\n            hidden: event.hidden,\n            source: event.source,\n            sourceIds: event.sourceIds,\n            text: event.text,\n            title: event.title,\n            // Details from the arguments\n            to,\n            toIds,\n        };\n    }\n\n    /**\n     * A place to put output for debug and reference.\n     * @type {Logger}\n     */\n    protected static logger = new Logger();\n\n    /**\n     * Encode the metadata of an event into a string to embed in the message\n     * @param data - event to gather details from\n     * @param format - Optional, markdown or plaintext, defaults to markdown\n     * @returns {string} - Text with data embedded\n     */\n    protected static stringifyMetadata(data: TransmitContext, format: 'markdown'|'plaintext' = 'markdown'): string {\n        // Retrieve publicity indicators from the environment\n        const publicIndicator = JSON.parse(process.env.MESSAGE_CONVERTOR_PUBLIC_INDICATORS)[0];\n        const privateIndicator = JSON.parse(process.env.MESSAGE_CONVERTOR_PRIVATE_INDICATORS)[0];\n        // Build the content with the indicator and genesis at the front\n        switch (format) {\n            case 'markdown':\n                return `[${data.hidden ? privateIndicator : publicIndicator}](${data.source})`;\n            case 'plaintext':\n                return `${data.hidden ? privateIndicator : publicIndicator}${data.source}`;\n            default:\n                throw new Error(`${format} format not recognised`);\n        }\n    }\n\n    /**\n     * Given a basic string this will extract a more rich context for the event, if embedded\n     * @param message - basic string that may contain metadata\n     * @returns {Metadata} - object of content, genesis and hidden\n     */\n    protected static extractMetadata(message: string): Metadata {\n        // Retrieve publicity indicators from the environment\n        const visibleArray = JSON.parse(process.env.MESSAGE_CONVERTOR_PUBLIC_INDICATORS);\n        const visible = visibleArray.join('|\\\\');\n        const hidden = JSON.parse(process.env.MESSAGE_CONVERTOR_PRIVATE_INDICATORS).join('|\\\\');\n        // Anchored with new line; followed by whitespace.\n        // Captured, the show/hide; brackets to enclose.\n        // Then comes genesis; parens may surround.\n        // The case we ignore; a Regex we form!\n        const findMetadata = new RegExp(`(?:^|\\\\r|\\\\n)(?:\\\\s*)\\\\[?(${hidden}|${visible})\\\\]?\\\\(?(\\\\w*)\\\\)?`, 'i');\n        const metadata = message.match(findMetadata);\n        if (metadata) {\n            // The content without the metadata, the word after the emoji, and whether the emoji is in the visible set\n            return {\n                content: message.replace(findMetadata, '').trim(),\n                genesis: metadata[2] || null,\n                hidden: !visibleArray.includes(metadata[1]),\n            };\n        }\n        // Return some default values if there wasn't any metadata\n        return {\n            content: message,\n            genesis: null,\n            hidden: true,\n        };\n    }\n\n    /**\n     * A singleton express instance for all web-hook based message services to share\n     * @type {Express}\n     */\n    private static _app: express.Express;\n\n    /**\n     * A boolean flag for if this object has been activated as a listener\n     * @type {boolean}\n     */\n    private listening: boolean = false;\n    /**\n     * An object of arrays storing events by trigger and their actions\n     */\n    private _eventListeners: { [event: string]: ServiceRegistration[] } = {};\n\n    /**\n     * Create or retrieve the singleton express app\n     * @returns {express.Express}\n     */\n    protected static get app(): express.Express {\n        if (!MessageService._app) {\n            // Either MESSAGE_SERVICE_PORT from environment or PORT from Heroku environment\n            const port = process.env.MESSAGE_SERVICE_PORT || process.env.PORT;\n            if (!port) {\n                throw new Error('No inbound port specified for express server');\n            }\n            // Create and log an express instance\n            MessageService._app = express();\n            MessageService._app.use(bodyParser.json());\n            MessageService._app.listen(port);\n            MessageService.logger.log(LogLevel.INFO, `---> Started express webserver on port '${port}'`);\n        }\n        return MessageService._app;\n    }\n\n    /**\n     * Build this service, specifying whether to awaken as a listener.\n     * @param listener - whether to start listening during construction\n     */\n    constructor(listener: boolean) {\n        super();\n        if (listener) {\n            this.listen();\n        }\n    }\n\n    /**\n     * Start the object listening if it isn't already\n     */\n    public listen() {\n        // Ensure the code in the child object gets executed a maximum of once\n        if (!this.listening) {\n            this.listening = true;\n            this.activateMessageListener();\n            MessageService.logger.log(LogLevel.INFO, `---> Started '${this.serviceName}' listener`);\n        }\n    }\n\n    /**\n     * Store an event of interest, so that the method gets triggered appropriately\n     * @param registration - Registration object with event trigger and other details\n     */\n    public registerEvent(registration: ServiceRegistration): void {\n        // Store each event registration in an object of arrays.\n        for (const event of registration.events) {\n            if (this._eventListeners[event] == null) {\n                this._eventListeners[event] = [];\n            }\n            this._eventListeners[event].push(registration);\n        }\n    }\n\n    /**\n     * Emit data to the service\n     * @param data - Service Emit Request to send, if relevant\n     * @returns {Promise<MessengerEmitResponse>} - Details of the successful transmission from the service\n     */\n    public sendData(data: ServiceEmitRequest): Promise<MessengerEmitResponse> {\n        // Check that the data has specifies a task for our emitter, before passing it on\n        if (data.contexts[this.serviceName]) {\n            return this.sendPayload(data.contexts[this.serviceName]);\n        }\n        // If this data has no task for us then no-op is the correct resolution\n        return Promise.resolve({\n            err: new Error(`No ${this.serviceName} context`),\n            source: this.serviceName,\n        });\n    }\n\n     /**\n     * Queue an event ready for running in a child.\n     * @param data - The WorkerEvent to add to the queue for processing.\n     */\n    public queueEvent(data: MessengerWorkerEvent) {\n        // This type guards a simple pass-through\n        super.queueEvent(data);\n    }\n\n    /**\n     * Promise to find the comment history of a particular thread\n     * @param thread - id of the thread to search\n     * @param room - id of the room in which the thread resides\n     * @param filter - criteria to match\n     */\n    public abstract fetchNotes(thread: string, room: string, filter: RegExp): Promise<string[]>\n\n    /**\n     * Promise to turn the data enqueued into a generic message format\n     * @param data - Raw data from the enqueue, remembering this is as dumb and quick as possible\n     * @returns {Promise<ReceiptContext>} - A promise that resolves to the generic form of the event\n     */\n    public abstract makeGeneric(data: MessengerEvent): Promise<ReceiptContext>;\n\n    /**\n     * Promise to turn a generic message format into a form suitable for emitting\n     * @param data - Generic message format to encode\n     * @returns {Promise<ServiceEmitContext>} - A promise that resolves to an emit context, which is as dumb as possible\n     */\n    public abstract makeSpecific(data: TransmitContext): Promise<ServiceEmitContext>;\n\n    /**\n     * Turns the generic, messenger, name for an event into a specific trigger name for this class\n     * @param eventType - Name of the event to translate, eg 'message'\n     * @returns {string} - This class's equivalent, eg 'post'\n     */\n    public abstract translateEventName(eventType: string): string;\n\n    /**\n     * Awaken this class as a listener\n     */\n    protected abstract activateMessageListener(): void;\n\n    /**\n     * Deliver the payload to the service. Sourcing the relevant context has already been performed\n     * @param data - The object to be delivered to the service\n     * @returns {Promise<MessengerEmitResponse>} - Response from the service endpoint\n     */\n    protected abstract sendPayload(data: ServiceEmitContext): Promise<MessengerEmitResponse>\n\n    /**\n     * Pass an event to registered listenerMethods\n     * @param event - enqueued event from the listener\n     * @returns {Bluebird<void>}\n     */\n    protected handleEvent = (event: MessengerEvent): Promise<void> => {\n        // Retrieve and execute all the listener methods, squashing their responses\n        const listeners = this._eventListeners[event.cookedEvent.type] || [];\n        return Promise.map(listeners, (listener) => {\n            return listener.listenerMethod(listener, event);\n        }).return();\n    }\n\n    /**\n     * Get a Worker object for the provided event, threaded by context\n     * @param event - event as enqueued by the listener\n     * @returns {Worker} - worker for the context associated\n     */\n    protected getWorker = (event: MessengerWorkerEvent): Worker<string|null> => {\n        // Attempt to retrieve an active worker for the context\n        const context = event.data.cookedEvent.context;\n        const retrieved = this.workers.get(context);\n        if (retrieved) {\n            return retrieved;\n        }\n        // Create and store a worker for the context\n        const created = new Worker<string>(context, this.removeWorker);\n        this.workers.set(context, created);\n        return created;\n    }\n\n    /**\n     * Get the service name, as required by the framework.\n     * @return  Name of the service.\n     */\n    abstract get serviceName(): string\n\n    /**\n     * Retrieve the SDK API instance handle for the service, should one exist.\n     * @return  Service SDK API handle or void.\n     */\n    abstract get apiHandle(): ServiceAPIHandle | void;\n}\n"],"sourceRoot":"../../lib"}